<!DOCTYPE html>
<html>
<head>
  <title>View Inner Surface of Sphere</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }
  </style>
</head>
<body>
<script>
  // this is where you paste the Three.js code we provided earlier
  const scene = new THREE.Scene();

  //var camera = new THREE.PerspectiveCamera(1000, window.innerWidth / window.innerHeight, 0.1, 1000);
  const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
  const listener = new THREE.AudioListener();
  camera.add( listener );

  // create a global audio source
  const sound = new THREE.Audio( listener );

  // load a sound and set it as the Audio object's buffer
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load( 'laser2.m4a', function( buffer ) {
    sound.setBuffer( buffer );
    sound.setLoop( true );
    sound.setVolume( 0.5 );
    //
  });
  window.addEventListener('resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
  // var cameraWidth = window.innerWidth / 2; // set the width of the camera view
  // var cameraHeight = window.innerHeight / 2; // set the height of the camera view
  // var camera = new THREE.OrthographicCamera(-cameraWidth, cameraWidth, cameraHeight, -cameraHeight, 0, 2000);

  //camera.position.set(0, 0, 10); // set the position of the camera

  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  var geometry = new THREE.IcosahedronGeometry(1000, 1);
  geometry.scale(-1, 1, 1); // flip the geometry to the inside
  const texture = new THREE.TextureLoader().load("starrysky5.png");
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(4, 4);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    combine: THREE.MultiplyOperation
  });
  material.repeat = true;
  var mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh); // add sphere to scene

  camera.position.set(0, 0, 0); // move camera inside the sphere

  const planet = {meshPlanet: null, meshPlanetA: null};

  var geometryPlanet = new THREE.IcosahedronGeometry(200, 16);
  const texturePlanet = new THREE.TextureLoader().load("2023-04-09 05.38.21.jpg");
  texturePlanet.wrapS = THREE.RepeatWrapping;
  texturePlanet.wrapT = THREE.RepeatWrapping;
  texturePlanet.repeat.set(1, 1);
  var materialPlanet = new THREE.MeshBasicMaterial({
    map: texturePlanet,
    combine: THREE.MultiplyOperation
  });
  //var materialPlanet = new THREE.MeshBasicMaterial({color: 0x00aaff});
  var meshPlanet = new THREE.Mesh(geometryPlanet, materialPlanet);

  // move the icosahedron close to the camera
  meshPlanet.position.set(200, -200, -250);

  scene.add(Ã§Planet);

  var geometryPlanetA = new THREE.IcosahedronGeometry(205, 16);
  const texturePlanetA = new THREE.TextureLoader().load("2k_neptune.jpeg");
  texturePlanet.wrapS = THREE.RepeatWrapping;
  texturePlanet.wrapT = THREE.RepeatWrapping;
  texturePlanet.repeat.set(1, 1);
  var materialPlanetA = new THREE.MeshBasicMaterial({
    map: texturePlanetA,
    combine: THREE.MultiplyOperation,
    transparent: true,
    opacity: 0.6
  });


  //var materialPlanet = new THREE.MeshBasicMaterial({color: 0x00aaff});
  var meshPlanetA = new THREE.Mesh(geometryPlanetA, materialPlanetA);

  // move the icosahedron close to the camera
  meshPlanetA.position.set(200, -200, -250);

  scene.add(meshPlanetA);

  const pVingA = new THREE.BoxGeometry(20, 5, 3);
  const materialPVingA = new THREE.MeshBasicMaterial({color: 0xc7c9ca})
  // const materialPVingA = new THREE.MeshPhongMaterial({
  //     color: 0xffff00
  // });
  meshPVingA = new THREE.Mesh(pVingA, materialPVingA);
  meshPVingA.position.set(-100, 0, -250);
  //meshPVingA.rotation.x += 0.4;
  //meshPVingA.rotation.y += -0.4;
  //meshPVingA.rotation.z += 0.4;
  scene.add(meshPVingA);
  const arrayMeshLaserRShooting = [];
  for (let i = 0; i < 10; i++) {
    const laserRShooting = new THREE.CylinderGeometry(0.3, 0.3, 20, 32);
    const materialLaserRShooting = new THREE.MeshBasicMaterial(
            {
              color: 0xff0000,
              transparent: true,
              opacity: 0.6
            });
    const meshLaserRShooting = new THREE.Mesh(laserRShooting, materialLaserRShooting);
    meshLaserRShooting.position.set(-100, 0, -300 - (i * 50));
    meshLaserRShooting.rotation.x = 0.5 * Math.PI;
    //meshLaserRShooting.rotation.y += -0.9;
    //meshLaserRShooting.rotation.z += -0.1;
    //scene.add(meshLaserRShooting);
    arrayMeshLaserRShooting.push(meshLaserRShooting)
  }


  function animate() {
    requestAnimationFrame(animate);
    // rotate the mesh over time
    meshPlanet.rotation.y += 0.0001;
    meshPlanetA.rotation.y += 0.000151;
    meshPlanetA.rotation.x += 0.000051;

    renderer.render(scene, camera);
  }

  animate();

  // Adjust camera position with arrow keys
  var arrow = {left: false, up: false, right: false, down: false};
  const shooting = {pVingA: false};
  document.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'ArrowLeft':
        arrow.left = true;
        break;
      case 'ArrowUp':
        arrow.up = true;
        break;
      case 'ArrowRight':
        arrow.right = true;
        break;
      case 'ArrowDown':
        arrow.down = true;
        break;
      case 'Space':
        shooting.pVingA = true;
        break;
    }
  });

  document.addEventListener('keyup', (event) => {
    switch (event.code) {
      case 'ArrowLeft':
        arrow.left = false;
        break;
      case 'ArrowUp':
        arrow.up = false;
        break;
      case 'ArrowRight':
        arrow.right = false;
        break;
      case 'ArrowDown':
        arrow.down = false;
        break;
      case 'Space':
        shooting.pVingA = false;
        break;
    }
  });

  function eventFunc() {
    // if (arrow.left) camera.position.x -= 0.1;
    // if (arrow.up) camera.position.y += 0.1;
    // if (arrow.right) camera.position.x += 0.1;
    // if (arrow.down) camera.position.y -= 0.1;
    if (arrow.left) {
      // Rotate the camera in local coordinates
      var localAxis = new THREE.Vector3(0, 1, 0); // Y-axis
      var angle = 0.01; // 45 degrees
      camera.rotateOnAxis(localAxis, angle);

      // Convert the camera rotation to global coordinates
      var quaternion = new THREE.Quaternion();
      camera.getWorldQuaternion(quaternion);
      camera.setRotationFromQuaternion(quaternion);

      //camera.rotation.y += 0.01;
    }
    if (arrow.up) {
      // Rotate the camera in local coordinates
      var localAxis = new THREE.Vector3(1, 0, 0); // Y-axis
      var angle = 0.01; // 45 degrees
      camera.rotateOnAxis(localAxis, angle);

      // Convert the camera rotation to global coordinates
      var quaternion = new THREE.Quaternion();
      camera.getWorldQuaternion(quaternion);
      camera.setRotationFromQuaternion(quaternion);
      //camera.rotation.x -= 0.01;
    }
    if (arrow.right) {
      // Rotate the camera in local coordinates
      var localAxis = new THREE.Vector3(0, 1, 0); // Y-axis
      var angle = -0.01; // 45 degrees
      camera.rotateOnAxis(localAxis, angle);

      // Convert the camera rotation to global coordinates
      var quaternion = new THREE.Quaternion();
      camera.getWorldQuaternion(quaternion);
      camera.setRotationFromQuaternion(quaternion);
      //camera.rotation.y -= 0.01;
    }
    if (arrow.down) {
      // Rotate the camera in local coordinates
      var localAxis = new THREE.Vector3(1, 0, 0); // Y-axis
      var angle = -0.01; // 45 degrees
      camera.rotateOnAxis(localAxis, angle);

      // Convert the camera rotation to global coordinates
      var quaternion = new THREE.Quaternion();
      camera.getWorldQuaternion(quaternion);
      camera.setRotationFromQuaternion(quaternion);
      console.log('arrow.down');
      //camera.rotation.x += 0.01;
    }
    if (shooting.pVingA) {
      console.log('arrayMeshLaserRShooting.length: ' + arrayMeshLaserRShooting.length)
      sound.play();
      let i = 0;
      for (let meshLaserRShooting of arrayMeshLaserRShooting) {
        scene.add(meshLaserRShooting);
        if (meshLaserRShooting.position.z < -1000) {
          meshLaserRShooting.position.z = -250 - (i * 50)
        }
        meshLaserRShooting.position.z -= 40;
        i++;
      }
    } else {
      sound.stop();
      let i = 0;
      for (let meshLaserRShooting of arrayMeshLaserRShooting) {
        scene.remove(meshLaserRShooting);
      }
    }

  }

  (function render() {
    requestAnimationFrame(render);
    eventFunc();
    renderer.render(scene, camera);
  })();


</script>
</body>
</html>